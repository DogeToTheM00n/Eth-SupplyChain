// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;
import "./accesscontrol/ConsumerRole.sol";
import "./accesscontrol/FarmerRole.sol";
import "./accesscontrol/DistributorRole.sol";
import "./accesscontrol/RetailerRole.sol";
import "./utils/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

contract Supplychain is ConsumerRole, RetailerRole, FarmerRole, DistributorRole, Ownable{
    using Counters for Counters.Counter;
    using Strings for uint256;
    
    address owner;

    uint private productcode;
    Counters.Counter private itemCounter;

    enum State{
        ProduceByFarmer,         // 0
        ForSaleByFarmer,         // 1
        PurchasedByDistributor,  // 2
        ShippedByFarmer,         // 3
        ReceivedByDistributor,   // 4
        ProcessedByDistributor,  // 5
        PackageByDistributor,    // 6
        ForSaleByDistributor,    // 7
        PurchasedByRetailer,     // 8
        ShippedByDistributor,    // 9
        ReceivedByRetailer,      // 10
        ForSaleByRetailer,       // 11
        PurchasedByConsumer      // 12
    }

    // Setting a Default state constant 
    State constant defaultState =State.ProduceByFarmer;
    struct Item{ 
        uint itemCounter;               // Counter for food items
        uint productcode;               // Universal Product Code, generated by the Farmer, goes on the package, can be verified by the Consumer
        string productID;               // stockunit + productcode
        address entityID;               // Metamask-Ethereum address of the current owner (Changes as the product moves through different stages)
        address originFarmerID;         // Metamask-Ethereum address of the Farmer 
        string  originFarmName;         // Farmer Name
        string  originFarmInformation;  // Farmer Information
        string  originFarmLatitude;     // Farm Latitude
        string  originFarmLongitude;    // Farm Longitude
        string  productNotes;           // Product Notes
        uint256 productDate;            // Product manufacture date 
        uint    productPrice;           // Product Price
        string  productImageHash;       // Hash of the Images for product store on IPFS
        uint    productSliced;          // Parent food item
        State   itemState;              // Product State as represented in the enum above
        address distributorID;          // Metamask-Ethereum address of the Distributor
        address retailerID;             // Metamask-Ethereum address of the Retailer
        address consumerID;             // Metamask-Ethereum address of the Consumer 
    }
    // Block number stuct
    struct Txblocks {
        uint FTD; // blockfarmerToDistributor
        uint DTR; // blockDistributorToRetailer
        uint RTC; // blockRetailerToConsumer
    }
    // Define a public mapping 'items' that maps the productcode to an Item.
    mapping (uint => Item) items;

    // Define a public mapping 'itemsHistory' that maps the productcode to an array of TxHash,
    // that track its journey through the supply chain -- to be sent from DApp.
    mapping (uint => Txblocks) itemsHistory;

    event ProduceByFarmer(uint productcode);         //1
    event ForSaleByFarmer(uint productcode);         //2
    event PurchasedByDistributor(uint productcode);  //3
    event ShippedByFarmer(uint productcode);         //4
    event ReceivedByDistributor(uint productcode);   //5
    event ProcessedByDistributor(uint productcode);  //6
    event PackagedByDistributor(uint productcode);   //7
    event ForSaleByDistributor(uint productcode);    //8
    event PurchasedByRetailer(uint productcode);     //9
    event ShippedByDistributor(uint productcode);    //10
    event ReceivedByRetailer(uint productcode);      //11
    event ForSaleByRetailer(uint productcode);       //12
    event PurchasedByConsumer(uint productcode);     //13
    
    // Define a modifer that checks to see if msg.sender == owner of the contract
    modifier onlyOwner() override{
        require(msg.sender == owner);
        _;
    }
    // Define a modifer that verifies the Caller
    modifier verifyCaller (address _address) {
        require(msg.sender == _address);
        _;
    }

    // Define a modifier that checks if the paid amount is sufficient to cover the price
    modifier paidEnough(uint _price) {
        require(msg.value >= _price);
        _;
    }

    // Define a modifier that checks the price and refunds the remaining balance
    modifier checkValue(uint _productcode, address payable addressToFund) {
        uint _price = items[_productcode].productPrice;
        uint  amountToReturn = msg.value - _price;
        (bool result,) =addressToFund.call{value:amountToReturn}("");
        require(result,"Refund failed");
        _;
    }

    // Item State Modifiers
    modifier producedByFarmer(uint _productcode) {
        require(items[_productcode].itemState == State.ProduceByFarmer);
        _;
    }

    modifier forSaleByFarmer(uint _productcode) {
        require(items[_productcode].itemState == State.ForSaleByFarmer);
        _;
    }

    modifier purchasedByDistributor(uint _productcode) {
        require(items[_productcode].itemState == State.PurchasedByDistributor);
        _;
    }

    modifier shippedByFarmer(uint _productcode) {
        require(items[_productcode].itemState == State.ShippedByFarmer);
        _;
    }

    modifier receivedByDistributor(uint _productcode) {
        require(items[_productcode].itemState == State.ReceivedByDistributor);
        _;
    }

    modifier processByDistributor(uint _productcode) {
        require(items[_productcode].itemState == State.ProcessedByDistributor);
        _;
    }

    modifier packagedByDistributor(uint _productcode) {
        require(items[_productcode].itemState == State.PackageByDistributor);
        _;
    }

    modifier forSaleByDistributor(uint _productcode) {
        require(items[_productcode].itemState == State.ForSaleByDistributor);
        _;
    }


    modifier shippedByDistributor(uint _productcode) {
        require(items[_productcode].itemState == State.ShippedByDistributor);
        _;
    }

    modifier purchasedByRetailer(uint _productcode) {
        require(items[_productcode].itemState == State.PurchasedByRetailer);
        _;
    }

    modifier receivedByRetailer(uint _productcode) {
        require(items[_productcode].itemState == State.ReceivedByRetailer);
        _;
    }

    modifier forSaleByRetailer(uint _productcode) {
        require(items[_productcode].itemState == State.ForSaleByRetailer);
        _;
    }

    modifier purchasedByConsumer(uint _productcode) {
        require(items[_productcode].itemState == State.PurchasedByConsumer);
        _;
    }

    constructor() payable {
        owner = msg.sender;
        productcode = 1;
        itemCounter.increment();
    }
    
    // Define a function 'kill'
    function kill() public {
        if (msg.sender == owner) {
        address payable ownerAddressPayable = payable(owner);
        selfdestruct(ownerAddressPayable);
        }
    }
    /*
    1st step in supplychain
    Allows farmer to create food item
    */

    function produceItemByFarmer(uint _productcode, string memory _originFarmName, string memory _originFarmInformation, string memory _originFarmLatitude, string memory _originFarmLongitude, string memory _productNotes, uint _price, string memory _productImageHash) public
        onlyFarmer() 
        {

        address distributorID;      // Empty distributorID address
        address retailerID;         // Empty retailerID address
        address consumerID;         // Empty consumerID address

        Item memory newProduce;               

        newProduce.itemCounter = itemCounter.current();     
        newProduce.productcode = _productcode;         
        newProduce.productID = (_productcode+itemCounter.current()).toString();  
        newProduce.entityID = msg.sender;  
        newProduce.originFarmerID = msg.sender;     
        newProduce.originFarmName = _originFarmName; 
        newProduce.originFarmInformation = _originFarmInformation;
        newProduce.originFarmLatitude = _originFarmLatitude; 
        newProduce.originFarmLongitude = _originFarmLongitude;  
        newProduce.productNotes = _productNotes;
        newProduce.productDate = block.timestamp;
        newProduce.productPrice = _price;  
        newProduce.productImageHash = _productImageHash;
        newProduce.productSliced = 0;
        newProduce.itemState = defaultState; 
        newProduce.distributorID = distributorID; 
        newProduce.retailerID = retailerID;
        newProduce.consumerID = consumerID;
        
        items[_productcode] = newProduce; 
        _help(_productcode);
        // Increment itemCounter
        itemCounter.increment();
        
        emit ProduceByFarmer(_productcode);
    }

    function _help(uint _productcode) internal {
        
        uint placeholder; // Block number place holder
        Txblocks memory txBlock; // create new txBlock struct
        txBlock.FTD = placeholder; // assign placeholder values
        txBlock.DTR = placeholder;
        txBlock.RTC = placeholder;

        itemsHistory[_productcode] = txBlock; // add txBlock to itemsHistory mapping by productcode
    }
    /*
    2nd step in supplychain
    Allows farmer to sell food item
    */ 
    function sellItemByFarmer(uint _productcode, uint _price) public
        onlyFarmer()                
        producedByFarmer(_productcode)
        verifyCaller(items[_productcode].entityID) 
        {
        items[_productcode].itemState = State.ForSaleByFarmer;
        items[_productcode].productPrice = _price;
        emit ForSaleByFarmer(_productcode);
    }
    /*
    3rd step in supplychain
    Allows distributor to purchase food Item
    */

    function purchaseItemByDistributor(uint _productcode) public payable
        onlyDistributor
        forSaleByFarmer(_productcode) 
        paidEnough(items[_productcode].productPrice)
        checkValue(_productcode, payable(msg.sender)) 
        {
        address payable ownerAddressPayable = payable(items[_productcode].originFarmerID); // make originFarmID payable
        ownerAddressPayable.transfer(items[_productcode].productPrice); // transfer funds from distributor to farmer
        items[_productcode].entityID = msg.sender;                      // update owner
        items[_productcode].distributorID = msg.sender;                 // update distributor
        items[_productcode].itemState = State.PurchasedByDistributor;   // update state
        itemsHistory[_productcode].FTD = block.number;                  // add block number
        emit PurchasedByDistributor(_productcode);
    }

      /*
    4th step in supplychain
    Allows farmer to ship food item purchased by distributor
     */

    function shippedItemByFarmer(uint _productcode) public payable
        onlyFarmer() 
        purchasedByDistributor(_productcode)
        verifyCaller(items[_productcode].originFarmerID)
        {
        items[_productcode].itemState = State.ShippedByFarmer; // update state
        emit ShippedByFarmer(_productcode);
    }
      
    /*
    5th step in supplychain
    Allows distributor to receive food item
    */
    function receivedItemByDistributor(uint _productcode) public
        onlyDistributor() 
        shippedByFarmer(_productcode)
        verifyCaller(items[_productcode].entityID)
        {
        items[_productcode].itemState = State.ReceivedByDistributor; // update state
        emit ReceivedByDistributor(_productcode);
    }

    /*
    6th step in supplychain
    Allows distributor to process food item
    */
    function processedItemByDistributor(uint _productcode,uint slices) public
        onlyDistributor() 
        receivedByDistributor(_productcode)
        verifyCaller(items[_productcode].entityID) 
        {
        items[_productcode].itemState = State.ProcessedByDistributor; // update state
        items[_productcode].productSliced = slices; // add slice amount
        emit ProcessedByDistributor(_productcode);
    }
    
    /*
    7th step in supplychain
    Allows distributor to package food item
    */
    function packageItemByDistributor(uint _productcode) public
        onlyDistributor() 
        processByDistributor(_productcode)
        verifyCaller(items[_productcode].entityID) 
        {
        items[_productcode].itemState = State.PackageByDistributor;
        emit PackagedByDistributor(_productcode);
    }

    /*
    8th step in supplychain
    Allows distributor to sell food item
    */ 
    function sellItemByDistributor(uint _productcode, uint _price) public
        onlyDistributor() 
        packagedByDistributor(_productcode)
        verifyCaller(items[_productcode].entityID) 
        {
            items[_productcode].itemState = State.ForSaleByDistributor;
            items[_productcode].productPrice = _price;
            emit ForSaleByDistributor(_productcode);
    }

    /*
    9th step in supplychain
    Allows retailer to purchase food item
    */
    function purchaseItemByRetailer(uint _productcode) public payable
        onlyRetailer() 
        forSaleByDistributor(_productcode)
        paidEnough(items[_productcode].productPrice)
        checkValue(_productcode, payable(msg.sender))
        {
        address payable ownerAddressPayable = payable(items[_productcode].distributorID);

        (bool result,) =ownerAddressPayable.call{value: items[_productcode].productPrice}("");
        require(result,"Failed to send product price to distributor");

        items[_productcode].entityID = msg.sender;
        items[_productcode].retailerID = msg.sender;
        items[_productcode].itemState = State.PurchasedByRetailer;
        itemsHistory[_productcode].DTR = block.number;
        emit PurchasedByRetailer(_productcode);
    }

    /*
    10th step in supplychain
    Allows Distributor to ship
    */
    function shippedItemByDistributor(uint _productcode) public
        onlyDistributor() 
        purchasedByRetailer(_productcode)
        verifyCaller(items[_productcode].distributorID) 
        {
        items[_productcode].itemState = State.ShippedByDistributor;
        emit ShippedByDistributor(_productcode);
    }
    /*
    11th step in supplychain
    */
    function receivedItemByRetailer(uint _productcode) public
        onlyRetailer() 
        shippedByDistributor(_productcode)
        verifyCaller(items[_productcode].entityID) 
        {
        items[_productcode].itemState = State.ReceivedByRetailer;
        emit ReceivedByRetailer(_productcode);
    }

    /*
    12th step in supplychain
    */
    function sellItemByRetailer(uint _productcode, uint _price) public
        onlyRetailer()  
        receivedByRetailer(_productcode)
        verifyCaller(items[_productcode].entityID) 
        {
        items[_productcode].itemState = State.ForSaleByRetailer;
        items[_productcode].productPrice = _price;
        emit ForSaleByRetailer(_productcode);
    }
    /*
    13th step in supplychain purchaseItemByConsumer
    */
    function purchaseItemByConsumer(uint _productcode) public payable
        onlyConsumer()  
        forSaleByRetailer(_productcode)
        paidEnough(items[_productcode].productPrice)
        checkValue(_productcode, payable(msg.sender))
        {
        items[_productcode].consumerID = msg.sender;
        address payable ownerAddressPayable = payable(items[_productcode].retailerID);
        (bool result,) =ownerAddressPayable.call{value: items[_productcode].productPrice}("");
        require(result,"Failed to send product price to retailer");

        items[_productcode].entityID = msg.sender;
        items[_productcode].consumerID = msg.sender;
        items[_productcode].itemState = State.PurchasedByConsumer;
        itemsHistory[_productcode].RTC = block.number;

        emit PurchasedByConsumer(_productcode);
    }

    // Define a function 'fetchItemBufferOne' that fetches the data
    function fetchItemBufferOne(uint _productcode) public view returns
        (
        uint _itemCounter,
        uint itemProductCode,
        address ownerID,
        address originFarmerID,
        string memory  originFarmName,
        string memory originFarmInformation,
        string memory originFarmLatitude,
        string memory originFarmLongitude,
        uint productDate,
        string memory productImageHash,
        uint productSliced
        )
        {

        Item memory item = items[_productcode];

        return
        (
        item.itemCounter,
        item.productcode,
        item.entityID,
        item.originFarmerID,
        item.originFarmName,
        item.originFarmInformation,
        item.originFarmLatitude,
        item.originFarmLongitude,
        item.productDate,
        item.productImageHash,
        item.productSliced
        );
    }

    // Define a function 'fetchItemBufferTwo' that fetches the data
    function fetchItemBufferTwo(uint _productcode) public view returns
        (
        uint    _itemCounter,
        uint    itemProductCode,
        string  memory  productID,
        string  memory productNotes,
        uint    productPrice,
        uint256 productDate,
        State   itemState,
        address distributorID,
        address retailerID,
        address consumerID
        )
        {
        Item memory item = items[_productcode];

        return
        (
        item.itemCounter,
        item.productcode,
        item.productID,
        item.productNotes,
        item.productPrice,
        item.productDate,
        item.itemState,
        item.distributorID,
        item.retailerID,
        item.consumerID
        );

    }

    // Define a function 'fetchItemHistory' that fetaches the data
    function fetchitemHistory(uint _productcode) public view returns
        (
        uint blockfarmerToDistributor,
        uint blockDistributorToRetailer,
        uint blockRetailerToConsumer
        )
        {
        Txblocks memory txblock = itemsHistory[_productcode];
        return
        (
            txblock.FTD,
            txblock.DTR,
            txblock.RTC
        );

    }

}